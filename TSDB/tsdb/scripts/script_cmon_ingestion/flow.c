/*-----------------------------------------------------------------------------
    Name: flow
    Generated By: netstorm
    Date of generation: 05/25/2012 04:15:00
    Flow details:
    Modification History:
-----------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <signal.h>
#include "ns_string.h"
#include "flow_util.c"

char *nslb_get_cur_date_time(char *time_string, int need_to_block_signal)
{       
  long    tloc;
  struct  tm result;
  struct  tm *lt;
  sigset_t sigset, oldset;

  (void)time(&tloc);
  
  //If need_to_block_signal is set then block all signals and unblock once calculated cur time stamp  
  if (need_to_block_signal == 1) {
    sigemptyset(&sigset);
    sigfillset(&sigset);
    sigprocmask(SIG_BLOCK, &sigset, &oldset);
    lt = localtime_r(&tloc, &result);
    sigprocmask(SIG_UNBLOCK, &sigset, &oldset);
  } else 
      lt = localtime_r(&tloc, &result);
  
  if (lt == (struct tm *)NULL)
    strcpy(time_string, "Error|Error");
  else
    sprintf(time_string, "%02d/%02d/%02d %02d:%02d:%02d",  lt->tm_mon + 1, lt->tm_mday, (1900 + lt->tm_year)%2000, lt->tm_hour, lt->tm_min, lt->tm_sec);
  return(time_string);
}

//Control connections related functions
int make_control_conn_with_ndc(char *ndc_ip,  char *ndc_port)
{ 
  char uri[64 + 1];
  int ret_val = -1; 
  int count = 0;

  snprintf(uri, 64, "%s:%s", ndc_ip, ndc_port);

  if(debug_level >= 2)
    fprintf (stderr, "\n*** message createrd %s, ndc_ip =%s, ndc_port= %s ", uri, ndc_ip, ndc_port);
                                         
  ns_save_string(uri, "cmon2ndc");       
    
  while(1)
  { 
   //TODO: Need to get protocol from file param
    ns_start_transaction("CmonControlConnection");
    ret_val = ns_web_websocket_connect("ID=3",
                                         "URI=ws://{cmon2ndc}/",
                                         "Origin=http://127.0.0.1",
                                         "Header=Accept-Language:en-us,en;q=0.5");

    if(ret_val != 0)
    {
      fprintf (stderr, "**Unable to connect with ndc server with ip %s and port\n", ndc_ip, ndc_port);

      ns_end_transaction("CmonControlConnection", 64);

      if(count == 10)
      {
        return ret_val;
      }
    }
    else
    {
      if(debug_level >= 2)
        fprintf (stderr , "*** Successfully connect with ndc server with ip %s and port\n", ndc_ip, ndc_port);

      ns_end_transaction("CmonControlConnection", NS_AUTO_STATUS);
      return ret_val;
    }
    ns_page_think_time(10);
    count++;
  }

  return ret_val;
}

int send_control_conn_request_to_ndc(char *server_ip, char *server_name, char *tier_name, char *cmon_version)
{
  int  ret_val = -1;
  //char cmon_version[64 + 1];
  char cmon_req[1024 + 1];
  int  cmon_pid=1234; //TODO: IF new user comes then cmonpid will change. It should be unique across the test
  //char tier_name[64 + 1];
  //char server_name[64 + 1];
  //char server_ip[64 + 1];


//  if(debug_level >= 1)
    fprintf(stderr, "****ControlConn tier_name = [%s], server_name = [%s], IP = %s\n", tier_name, server_name, server_ip);
  
  //TODO: Parameterize machinetype, agenttype. Also check significance of lastConnectionTimeStamp
  //What is format of supportedProtocols and why it is working with TCP when running on WS
  sprintf(cmon_req, "cmon_ctrl_msg_req:Server=%s;tierName=%s;"
                    "cmonVersion=%s;serverIp=%s;cmonHome=/home/cavisson/monitors;cmonPid=%d;"
                    "cmonJavaHome=/home/cavisson/apps/jdk1.8.0_121/jre;cmonStartTime=1545049957483;machineType=LinuxEx;"
                    "instance=CMON;hostName=netstorm-ProLiant-ML10;agentType=Java;requestType=1;lastConnectionTimeStamp=-1;"
                    "connDuration=0;connDestination=NA;supportedProtocols=TCP;cmon_env_lmd=1545049161000\n",
                     server_name, tier_name, cmon_version, server_ip, cmon_pid);

  ns_save_string(cmon_req, "cmon2ndc");

  if(debug_level >= 1)
    fprintf(stderr, "\n Ctrl conn request [CMON->NDC] = [%s]\n", ns_eval_string("{cmon2ndc}"));

  ns_start_transaction("CmonControlRegistry");

  ret_val = ns_web_websocket_send("ID=3",
                                  "BUFFER={cmon2ndc}",
                                  "ISBINARY=0");

  //TODO: Add every tx with fail name
  ns_end_transaction("CmonControlRegistry", NS_AUTO_STATUS);

  if(debug_level >= 2)
    fprintf (stdout, "\n[CMON->NDC] return = %d\n", ret_val);

  if (ret_val !=0)
    fprintf (stderr,"*** Error in sending control message to ndc\n");
else
    fprintf(stderr, "\nControl Connection Successully make %lld");

  return ret_val;
}

int make_data_conn_with_ndc(char *ndc_ip, char *ndc_port)
{ 
  int ret_val = -1;
  char uri[64];
  
  snprintf(uri, 64, "%s:%s", ndc_ip, ndc_port); 

  if(debug_level >= 1)
    fprintf (stderr, "\n*** message createrd %s, ndc_ip =%s, ndc_port= %s ", uri, ndc_ip, ndc_port);
  
  ns_save_string(uri, "cmon2ndc");
  ns_start_transaction("CmonDataConnection");
  
  ret_val = ns_web_websocket_connect("ID=4",
                                         "URI=ws://{cmon2ndc}/",
                                         "Origin=http://127.0.0.1",
                                         "Header=Accept-Language:en-us,en;q=0.5");

  ns_end_transaction("CmonDataConnection", NS_AUTO_STATUS);

  return ret_val;
}

//WS frame size has no limit(very large limit).
int send_data_conn_request_to_ndc(int testidx, char *server_ip, char *server_name, char *tier_name, char *cmon_version)
{
  int  ret_val = -1;
  //char cmon_version[64 + 1];
  char cmon_req[1024 + 1];
  int  cmon_pid=1234;
  //char tier_name[64 + 1];
  //char server_name[64 + 1];
  //char server_ip[64 + 1];
  char tx_name[128];


 //if(debug_level >= 1)
    fprintf(stderr, "****DataConn tier_name = [%s], server_name = [%s], IP = %s\n", tier_name, server_name, server_ip);

  //TODO EXTRACT TR from TYPE 1 
  //TODO REMOVE EXTRA ARGUMENT /make a new function 
  sprintf(cmon_req, "cmon_data_msg_req:Tier=%s;Server=%s;Instance=CMON;testrun=%d;\n", tier_name, server_name, testidx);

  ns_save_string(cmon_req, "cmon2ndc");

  if(debug_level >= 1)
    fprintf(stdout, "\n[CMON->NDC] = [%s]\n", ns_eval_string("{cmon2ndc}"));

  ns_start_transaction("CmonDataRegistry");

  ret_val = ns_web_websocket_send("ID=4",
                                  "BUFFER={cmon2ndc}",
                                  "ISBINARY=0");

  if(debug_level >= 1)
    fprintf (stdout, "\n%s[CMON->NDC] return = %d\n", __FUNCTION__, ret_val);

  if (ret_val !=0){
    sprintf(tx_name, "CmonDataRegistry_%d", ret_val);
    ns_end_transaction_as("CmonDataRegistry", 64, tx_name);
    fprintf (stderr,"*** %s, Error in sending data connection message to ndc. Error code = %d\n", __FUNCTION__, ret_val);
  }
  else
    ns_end_transaction("CmonDataRegistry", NS_AUTO_STATUS);

  return ret_val;
}

int send_monitor_data_to_ndc_on_data_conn(char *data)
{
  int  ret_val = -1; 
  char tx_name[128];

  ns_save_string(data, "cmon2ndc");
  ns_start_transaction("CmonMonitorDataSend");
  int count = 5; 
  while(count>0)
  {
    ns_start_transaction("CmonMonitorDataSendLoop");
    ret_val = ns_web_websocket_send("ID=4",
                                      "BUFFER={cmon2ndc}", 
                                      "ISBINARY=0");
    ns_end_transaction("CmonMonitorDataSendLoop", 0);
    if(ret_val == 11)
    {
      count--;
      ns_page_think_time(2);
      continue;
    }
    else
      break;
  }
  
  //cmon_log_level = 0;
  if(debug_level >= 1)
    fprintf(stdout, "\n%s, [CMON->DATA NDC] return = %d\n", __FUNCTION__, ret_val);

  if (ret_val !=0){
    fprintf (stderr,"*** %s Error in sending data connection message to ndc\n", __FUNCTION__);
    sprintf(tx_name, "CmonMonitorDataSend_%d", ret_val);
    ns_end_transaction_as("CmonMonitorDataSend", 64, tx_name);
  }
  else
  {
    ns_end_transaction("CmonMonitorDataSend", NS_AUTO_STATUS);
  }

  return ret_val;
}

int send_msg_to_ndc_on_control_connection(char *msg, char *msg_type)
{
  int  ret_val = -1;

  ns_save_string(msg, "cmon2ndc");
  ns_start_transaction(msg_type);

  ret_val = ns_web_websocket_send("ID=3",
                                  "BUFFER={cmon2ndc}",
                                  "ISBINARY=0");

  ns_end_transaction(msg_type, NS_AUTO_STATUS);

  if(debug_level >= 1)
    fprintf (stdout, "\n%s, [CMON->NDC] msg = %s, return = %d\n", __FUNCTION__, msg, ret_val);

  if (ret_val !=0)
    fprintf (stderr,"*** Error in sending %s message to ndc\n", msg);

  return ret_val;
}

//TODO TESTIDX SET
//TODO DVM MONITOR
//TODO MONITOR STOP
//TODO BUFFER REALLOC
//TODO INTERVAL SET
//TODO HANDLING OF ALL CONFIGURATION in GDF File
//TODO GDF NOT Entry not present in gdf file
//TODO LPS MONITOR
//TODO NS_SERVER_ADMIN
//TODO LOGGING
//TODO PARSING LOGIC OPTIMIZE needs to on based of type not cm_init
//TODO RUN TIME ADD
void flow()
{
  #define BUFF_SIZE 1280000
  long counter = 0;
  char buffer[BUFF_SIZE];//Making this big as do not know how much data will be coming//TODO NEED TO REALLOC
  int resp_size = 0;    
  int ret = 0;
  char send_monitor_data = 0;
  char curr_time_buffer[100];
  char create_data_conn = 1;
  long    tloc;
  struct  tm result;
  struct  tm *lt;

  gdf_data *gdf_data_struct = NULL ;
  int total_gdf_entries = 0;
  int max_gdf_entries = 0;
 #ifdef NS_DEBUG_ON
  FILE *fp = NULL;
 // int data_send_interval = 60000;//In ms /TODO fill from cm_init request and for every monitor it will be differnt
  //long last_time_data_sent = 0; 
  //long curr_time;
  fp = fopen("/tmp/script.log", "a+");
 #endif
  char ndc_ip[64 + 1]; 
  char ndc_port[8 + 1];
  char cmon_version[64 + 1];
  char tier_name[64 + 1];
  char server_name[64 + 1];
  char server_ip[64 + 1]; 
  //int debug_level = 1;
  initialize_variable();

  get_server_ip_name(server_ip, server_name, tier_name, cmon_version);
  ns_advance_param("ControllerIP");

  strcpy(ndc_ip, ns_eval_string("{ControllerIP}"));
  strcpy(ndc_port, ns_eval_string("{ControllerPort}"));

  // Connecting to WebSocket Server
  ret = make_control_conn_with_ndc(ndc_ip, ndc_port);

  if( ret != 0 )
  //printf(" make_control_conn_with_ndc failed ");
    goto err;

  // Sending data to ndc Server for making control  connection
  ret = send_control_conn_request_to_ndc(server_ip, server_name, tier_name, cmon_version);  

  if (ret !=0)
  { 
     fprintf(stderr, " send_control_conn_request_to_ndc failed ");
    goto err;
  }
  int testidx = 0;
  
  int fill_nan_set=0;
  int fill_nan = atoi(ns_eval_string("{FILL_NAN}"));
  while(1)
  {
    if(debug_level >= 1)
      fprintf(stderr, "\n****** Sending HB Req By (NVM, VUser, Session) = (%d, %d, %d)\n", ns_get_nvmid(), ns_get_userid(), ns_get_sessid());
    ret = send_msg_to_ndc_on_control_connection("cmon_get_config_msg_req\n", "CmonHeartBeat");

    if (ret != 0)
   // printf(" send_msg_to_ndc_on_control_connection failed ");
      goto err;

    ns_start_transaction("CmonHeartBeatResp");
    while(1)
    {
     // fprintf(stderr, "\n going for monitors data");
      resp_size = 0;
      memset(buffer,0, BUFF_SIZE);
      read_msg_from_ndc_on_ctrl_conn(buffer, "CmonHeartBeatRespLoop", &resp_size);
      //fprintf(stderr, "Response size = %d\n", resp_size);
      
      //Check if init messages has come. If yes then fill gdf name, mon id and make data connection
      if(resp_size)
      {
        ret = parse_hb_response_message(buffer, resp_size, &gdf_data_struct, &total_gdf_entries, &max_gdf_entries, &testidx);
        if(debug_level >= 1)
          fprintf(stderr, "Return value = %d from parse_hb_response_message()\n", ret);
        
        if(ret == 0) //Monitor Request Received
        {
          //fprintf(stderr, "\n Monitor Data Receive");
          send_monitor_data = 1;
        }
	if(ret == 2)
	{
	   fprintf(stderr, "Going to close data connection seems like CMT test stopped ");
	   goto err;
	}
      }
      else
        break;
    }
    ns_end_transaction("CmonHeartBeatResp", 0);
    //Data conenction already created. It means already got init msg. Create data and send
    if(send_monitor_data == 1)
    {
      if(create_data_conn == 1)
      {
        ret = make_data_conn_with_ndc(ndc_ip, ndc_port);

        if(ret != 0)
        {
          printf(" make_data_conn_with_ndc failed ");
          goto err;

        }
        ret = send_data_conn_request_to_ndc(testidx, server_ip, server_name, tier_name, cmon_version);

        if(ret != 0)
        //printf(" send_data_conn_request_to_ndc failed ");
          goto err;

        //fprintf(stderr, "   Data Connection Successully make\n");

        create_data_conn = 0;
      }
       
      gdf_data *gdf_data_struct_tmp = NULL;

      //fill structure of gdf_data and return back monitor_data in out_buff
      //Make response to send the monitor data to the NDC
      //Using buffer variable to create the response of the monitor
     fill_nan_set++;

     for( int idx = 0; idx < total_gdf_entries; idx++)
     { 
       gdf_data_struct_tmp = gdf_data_struct + idx;
       gdf_data_struct_tmp->curr_time = ns_get_ms_stamp();

      #ifdef NS_DEBUG_ON
       fprintf(stderr, "GDF name %s , Freq %d, FreqDouble %lf ,FreqLongTimefacotr %ld \n", gdf_data_struct_tmp->gdf_name ,gdf_data_struct_tmp->frequency, (double)gdf_data_struct_tmp->frequency, (long)((double)gdf_data_struct_tmp->frequency * time_factor));
      #endif

       if((gdf_data_struct_tmp->curr_time - gdf_data_struct_tmp->last_time_data_sent) >=(long)((double)gdf_data_struct_tmp->frequency * time_factor))
       {
         #ifdef NS_DEBUG_ON
          fprintf(fp,"%s|gdf_name %s cur time %lld last_time_data_sent %lld frequency %d\n", nslb_get_cur_date_time(curr_time_buffer, 1), gdf_data_struct_tmp->gdf_name, gdf_data_struct_tmp->curr_time, gdf_data_struct_tmp->last_time_data_sent,  gdf_data_struct_tmp->frequency);
          #endif

          if ( fill_nan_set == 5 && fill_nan == 1)
           {	
	      // Sending nan 
              fprintf(stderr, "Not sending data for this sample ,");
              ret = 0;
	   }
          else
	  { 
          make_monitor_data(gdf_data_struct_tmp, buffer, total_gdf_entries); 
          ret = send_monitor_data_to_ndc_on_data_conn(buffer);
	  }
         #ifdef NS_DEBUG_ON
          fprintf(fp,"%s|gdf_name %s cur time %lld last_time_data_sent %lld frequency %d and data %s\n", nslb_get_cur_date_time(curr_time_buffer, 1), gdf_data_struct_tmp->gdf_name, gdf_data_struct_tmp->curr_time, gdf_data_struct_tmp->last_time_data_sent,  gdf_data_struct_tmp->frequency, buffer);
          #endif
          if(ret != 0)
        //printf(" send_monitor_data_to_ndc_on_data_conn failed ");
            goto err;
          gdf_data_struct_tmp->last_time_data_sent = gdf_data_struct_tmp->curr_time;
       }
     }
     if (fill_nan_set == 5)
	fill_nan_set =0;
   }
    ns_page_think_time(1);
  }//While 

err:
 fprintf(stderr, "WB CLOSE\n\n");  
  ns_start_transaction("WebSocket_Close");
  ns_web_websocket_close("ID=3",
"CODE=1000",
"REASON=Any reson");
  ns_web_websocket_close("ID=4",
"CODE=1000",
"REASON=Any reson");
  ns_end_transaction("WebSocket_Close", NS_AUTO_STATUS);
  return;
}
